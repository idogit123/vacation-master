import { IDisposable } from "../../Types/Contracts";
import { DocumentStore } from "../DocumentStore";
import { SubscriptionWorkerOptions } from "./SubscriptionWorkerOptions";
import { SubscriptionBatch } from "./SubscriptionBatch";
import { EmptyCallback } from "../../Types/Callbacks";
export declare class SubscriptionWorker<T extends object> implements IDisposable {
    private readonly _documentType;
    private readonly _revisions;
    private readonly _logger;
    private readonly _store;
    private readonly _dbName;
    private _processingCanceled;
    private readonly _options;
    private _tcpClient;
    private _parser;
    private _disposed;
    private _subscriptionTask;
    private _forcedTopologyUpdateAttempts;
    private _emitter;
    constructor(options: SubscriptionWorkerOptions<T>, withRevisions: boolean, documentStore: DocumentStore, dbName: string);
    getWorkerId(): string;
    dispose(): void;
    private _redirectNode;
    private _subscriptionLocalRequestExecutor;
    protected subscriptionTcpVersion: number;
    get currentNodeTag(): string;
    get subscriptionName(): string;
    private _connectToServer;
    private _negotiateProtocolVersionForSubscription;
    private _legacyTryGetTcpInfo;
    private _sendOptions;
    private _ensureParser;
    private _readServerResponseAndGetVersion;
    private _sendDropMessage;
    private _assertConnectionState;
    private _processSubscription;
    private _emitBatchAndWaitForProcessing;
    private _readSingleSubscriptionBatchFromServer;
    private _throwInvalidServerResponse;
    private _throwSubscriptionError;
    private _readNextObject;
    private _sendAck;
    private _runSubscriptionAsync;
    private _lastConnectionFailure;
    private _supportedFeatures;
    private _assertLastConnectionFailure;
    private _shouldTryToReconnect;
    private _closeTcpClient;
    on(event: "batch", handler: (value: SubscriptionBatch<T>, callback: EmptyCallback) => void): this;
    on(event: "error", handler: (error?: Error) => void): this;
    on(event: "end", handler: (error?: Error) => void): this;
    on(event: "unexpectedSubscriptionError", handler: (error?: Error) => void): this;
    on(event: "onEstablishedSubscriptionConnection", handler: (value: SubscriptionWorker<any>) => void): this;
    on(event: "afterAcknowledgment", handler: (value: SubscriptionBatch<T>, callback: EmptyCallback) => void): this;
    on(event: "connectionRetry", handler: (error?: Error) => void): this;
    off(event: "batch", handler: (value: SubscriptionBatch<T>, callback: EmptyCallback) => void): this;
    off(event: "error", handler: (error?: Error) => void): this;
    off(event: "unexpectedSubscriptionError", handler: (error?: Error) => void): this;
    off(event: "onEstablishedSubscriptionConnection", handler: (value: SubscriptionWorker<any>) => void): this;
    off(event: "end", handler: (error?: Error) => void): this;
    off(event: "afterAcknowledgment", handler: (value: SubscriptionBatch<T>, callback: EmptyCallback) => void): this;
    off(event: "connectionRetry", handler: (error?: Error) => void): this;
    removeListener(event: "batch", handler: (value: SubscriptionBatch<T>, callback: EmptyCallback) => void): this;
    removeListener(event: "error", handler: (error?: Error) => void): this;
    removeListener(event: "unexpectedSubscriptionError", handler: (error?: Error) => void): this;
    removeListener(event: "onEstablishedSubscriptionConnection", handler: (value: SubscriptionWorker<any>) => void): this;
    removeListener(event: "end", handler: (error?: Error) => void): this;
    removeListener(event: "afterAcknowledgment", handler: (value: SubscriptionBatch<T>, callback: EmptyCallback) => void): this;
    removeListener(event: "connectionRetry", handler: (error?: Error) => void): this;
    private static _mapToLocalObject;
}
