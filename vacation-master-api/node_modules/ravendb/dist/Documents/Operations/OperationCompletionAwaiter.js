"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationCompletionAwaiter = void 0;
const GetOperationStateOperation_1 = require("./GetOperationStateOperation");
const Exceptions_1 = require("../../Exceptions");
const Exceptions_2 = require("../../Exceptions");
const PromiseUtil_1 = require("../../Utility/PromiseUtil");
const KillOperationCommand_1 = require("../Commands/KillOperationCommand");
class OperationCompletionAwaiter {
    get id() {
        return this._id;
    }
    constructor(requestExecutor, conventions, id, nodeTag) {
        this._requestExecutor = requestExecutor;
        this._conventions = conventions;
        this._id = id;
        this._nodeTag = nodeTag;
    }
    async _fetchOperationStatus() {
        const command = this._getOperationStateCommand(this._conventions, this._id, this._nodeTag);
        await this._requestExecutor.execute(command);
        return command.result;
    }
    _getOperationStateCommand(conventions, id, nodeTag) {
        return new GetOperationStateOperation_1.GetOperationStateCommand(this._id, nodeTag);
    }
    get nodeTag() {
        return this._nodeTag;
    }
    set nodeTag(nodeTag) {
        this._nodeTag = nodeTag;
    }
    waitForCompletion() {
        const operationStatusPolling = () => {
            return Promise.resolve()
                .then(() => this._fetchOperationStatus())
                .then((operationStatusResult) => {
                const operationStatus = operationStatusResult.status;
                switch (operationStatus) {
                    case "Completed":
                        return;
                    case "Canceled":
                        (0, Exceptions_1.throwError)("OperationCanceledException", `Operation of ID ${this._id} has been canceled.`);
                        break;
                    case "Faulted": {
                        const faultResult = operationStatusResult.result;
                        const errorSchema = Object.assign({}, faultResult, { url: this._requestExecutor.getUrl() });
                        throw Exceptions_2.ExceptionDispatcher.get(errorSchema, faultResult.statusCode);
                    }
                }
                return (0, PromiseUtil_1.delay)(500)
                    .then(() => operationStatusPolling());
            });
        };
        return Promise.resolve(operationStatusPolling());
    }
    _getKillOperationCommand(id, nodeTag) {
        return new KillOperationCommand_1.KillOperationCommand(id, nodeTag);
    }
    async kill() {
        const command = this._getKillOperationCommand(this._id, this.nodeTag);
        await this._requestExecutor.execute(command);
    }
}
exports.OperationCompletionAwaiter = OperationCompletionAwaiter;
//# sourceMappingURL=OperationCompletionAwaiter.js.map