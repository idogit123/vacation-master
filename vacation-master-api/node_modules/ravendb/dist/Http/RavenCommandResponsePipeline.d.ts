/// <reference path="../Types/readable-stream.d.ts" />
/// <reference types="node" />
import { EventEmitter } from "events";
import { ObjectKeyCaseTransformStreamOptions } from "../Mapping/Json/Streams/ObjectKeyCaseTransformStream";
import { ObjectKeyCaseTransformProfile } from "../Mapping/Json/Conventions";
import { CasingConvention } from "../Utility/ObjectUtil";
import * as stream from "readable-stream";
import { CollectResultStreamOptions } from "../Mapping/Json/Streams/CollectResultStream";
import { ErrorFirstCallback } from "../Types/Callbacks";
export interface RavenCommandResponsePipelineOptions<TResult> {
    collectBody?: boolean | ((body: string) => void);
    jsonAsync?: {
        filters: any[];
    };
    jsonlAsync?: {
        transforms: stream.Transform[];
    };
    jsonSync?: boolean;
    streamKeyCaseTransform?: ObjectKeyCaseTransformStreamOptions;
    collectResult: CollectResultStreamOptions<TResult>;
    transform?: stream.Stream;
}
export declare class RavenCommandResponsePipeline<TStreamResult> extends EventEmitter {
    private readonly _opts;
    private _body;
    private constructor();
    static create<TResult>(): RavenCommandResponsePipeline<TResult>;
    parseJsonAsync(filters?: any[]): this;
    parseJsonSync(): this;
    parseJsonlAsync(valueExtractor: (obj: any) => any, options?: {
        transforms?: stream.Transform[];
    }): this;
    collectBody(callback?: (body: string) => void): this;
    objectKeysTransform(defaultTransform: CasingConvention, profile?: ObjectKeyCaseTransformProfile): this;
    objectKeysTransform(opts: ObjectKeyCaseTransformStreamOptions): this;
    collectResult(reduce: (result: TStreamResult, next: object) => TStreamResult, init: TStreamResult): RavenCommandResponsePipeline<TStreamResult>;
    collectResult(opts: CollectResultStreamOptions<TStreamResult>): RavenCommandResponsePipeline<TStreamResult>;
    stream(src: stream.Stream): stream.Readable;
    stream(src: stream.Stream, dst: stream.Writable, callback: ErrorFirstCallback<void>): stream.Stream;
    private _appendBody;
    private _buildUp;
    process(src: stream.Stream): Promise<TStreamResult>;
}
