"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamResultsIntoStream = exports.getDocumentStreamResultsIntoStreamPipeline = exports.getDocumentResultsAsObjects = void 0;
const stream = require("readable-stream");
const RavenCommandResponsePipeline_1 = require("../../../Http/RavenCommandResponsePipeline");
const Stringer_1 = require("stream-json/jsonl/Stringer");
const Stringer_2 = require("stream-json/Stringer");
const Pick_1 = require("stream-json/filters/Pick");
const StreamArray_1 = require("stream-json/streamers/StreamArray");
const ObjectUtil_1 = require("../../../Utility/ObjectUtil");
function getDocumentResultsAsObjects(conventions, queryStream) {
    const pipeline = RavenCommandResponsePipeline_1.RavenCommandResponsePipeline.create();
    const keysTransform = new stream.Transform({
        objectMode: true,
        transform(chunk, encoding, callback) {
            let value = chunk["value"];
            if (!value) {
                return callback();
            }
            if (conventions) {
                value = ObjectUtil_1.ObjectUtil.transformDocumentKeys(value, conventions);
            }
            callback(null, { ...chunk, value });
        }
    });
    return conventions.useJsonlStreaming
        ? pipeline.parseJsonlAsync(queryStream ? x => x["Item"] : x => x, {
            transforms: [keysTransform]
        })
        : pipeline.parseJsonAsync([
            (0, Pick_1.pick)({ filter: "Results" }),
            (0, StreamArray_1.streamArray)(),
            keysTransform
        ]);
}
exports.getDocumentResultsAsObjects = getDocumentResultsAsObjects;
function getDocumentStreamResultsIntoStreamPipeline(conventions) {
    const pipeline = RavenCommandResponsePipeline_1.RavenCommandResponsePipeline.create();
    return conventions.useJsonlStreaming
        ? pipeline.parseJsonlAsync(x => x["Item"], {
            transforms: [
                (0, Stringer_1.stringer)({ replacer: (key, value) => key === '' ? value.value : value }),
            ]
        })
        : pipeline
            .parseJsonAsync([
            (0, Stringer_2.stringer)({ useValues: true })
        ]);
}
exports.getDocumentStreamResultsIntoStreamPipeline = getDocumentStreamResultsIntoStreamPipeline;
async function streamResultsIntoStream(bodyStream, conventions, writable) {
    return new Promise((resolve, reject) => {
        getDocumentStreamResultsIntoStreamPipeline(conventions)
            .stream(bodyStream, writable, (err) => {
            err ? reject(err) : resolve();
        });
    });
}
exports.streamResultsIntoStream = streamResultsIntoStream;
//# sourceMappingURL=Pipelines.js.map